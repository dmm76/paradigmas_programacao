<!DOCTYPE html><html lang="pt-br"> <head><meta charset="UTF-8"><title>RevisÃ£o de Paradigmas</title><meta name="description" content><link rel="stylesheet" href="/style.css"></head> <body> <header class="site-header"> <div class="container header-inner"> <h1 class="logo">RevisÃ£o de Paradigmas</h1> <nav class="nav"> <a href="/">InÃ­cio</a> <div class="nav-menu"> <button type="button" class="nav-menu-toggle">
Aulas
<span aria-hidden="true">â–¾</span> </button> <div class="nav-dropdown"> <a href="/aula01">Aula 01</a> <a href="/aula09">Aula 09</a> </div> </div> </nav> </div> </header> <main class="container main-content"> <h1 id="-aula-01--paradigmas-de-linguagens-de-programaÃ§Ã£o-visÃ£o-geral">ğŸŒŸ Aula 01 â€“ Paradigmas de Linguagens de ProgramaÃ§Ã£o (visÃ£o geral)</h1>
<h3 id="versÃ£o-especial-para-memorizaÃ§Ã£o-eficiente-aprendizado-acelerado-e-prova"><em>VersÃ£o especial para memorizaÃ§Ã£o eficiente, aprendizado acelerado e prova.</em></h3>
<blockquote>
<p><strong>Fraseâ€‘Ã¢ncora da aula:</strong><br>
<em>â€œParadigma Ã© o <strong>jeito de pensar</strong> o problema. Linguagem Ã© sÃ³ a <strong>ferramenta</strong> para implementar esse jeito de pensar.â€</em></p>
</blockquote>
<hr>
<h2 id="1-abertura-da-disciplina">1. Abertura da disciplina</h2>
<ul>
<li>Disciplina: <strong>Paradigmas de Linguagens de ProgramaÃ§Ã£o</strong></li>
<li>Objetivo geral:
<ul>
<li>Ir <strong>alÃ©m do â€œcomo programarâ€</strong> em uma linguagem especÃ­fica</li>
<li>Entender <strong>por que</strong> as linguagens sÃ£o diferentes</li>
<li>Desenvolver um <strong>arsenal mental</strong> de formas de pensar problemas</li>
</ul>
</li>
<li>Mesmo quem <strong>nÃ£o quer ser desenvolvedor full-time</strong> se beneficia:
<ul>
<li>Entender melhor o trabalho da equipe tÃ©cnica</li>
<li>Saber pedir o que precisa de forma clara</li>
<li>Reconhecer limitaÃ§Ãµes e pontos fortes das tecnologias</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Gatilho de memÃ³ria:</strong> imagine que vocÃª Ã© o â€œarquitetoâ€ do sistema, nÃ£o sÃ³ o â€œpedreiro do cÃ³digoâ€.</p>
</blockquote>
<hr>
<h2 id="2-por-que-nÃ£o-focar-em-uma-Ãºnica-linguagem">2. Por que nÃ£o focar em uma Ãºnica linguagem?</h2>
<p>Muita gente pensa:</p>
<blockquote>
<p>â€œPor que nÃ£o estudar sÃ³ a linguagem mais popular do mercado e pronto?â€</p>
</blockquote>
<p>Problema dessa visÃ£o:</p>
<ul>
<li>VocÃª fica <strong>preso Ã  moda</strong> do momento</li>
<li>Cada novo problema complexo exige um jeito de pensar diferente</li>
<li>Sem entender paradigmas, vocÃª:
<ul>
<li>Confunde <strong>sintaxe</strong> com <strong>semÃ¢ntica</strong></li>
<li>Escolhe ferramenta pela <strong>popularidade</strong>, nÃ£o pela <strong>adequaÃ§Ã£o tÃ©cnica</strong></li>
</ul>
</li>
</ul>
<h3 id="benefÃ­cios-de-estudar-paradigmas">BenefÃ­cios de estudar paradigmas</h3>
<ul>
<li>Aumenta sua <strong>capacidade de adaptaÃ§Ã£o</strong></li>
<li>Ajuda a <strong>reduzir bugs</strong> por confusÃ£o de significado</li>
<li>Facilita migrar entre linguagens (Java â†’ C# â†’ Python â†’ JavaScript etc.)</li>
<li>Permite escolher <strong>â€œa linguagem certa para o problema certoâ€</strong></li>
</ul>
<blockquote>
<p><strong>Fraseâ€‘Ã¢ncora:</strong><br>
<em>â€œNÃ£o existe linguagem perfeita, existe linguagem mais adequada para o problema.â€</em></p>
</blockquote>
<hr>
<h2 id="3-o-que-define-uma-linguagem-de-programaÃ§Ã£o">3. O que define uma linguagem de programaÃ§Ã£o?</h2>
<p>Pense em uma linguagem de programaÃ§Ã£o como um <strong>idioma</strong>:</p>
<ol>
<li>
<p><strong>VocabulÃ¡rio (tokens)</strong></p>
<ul>
<li>Palavras reservadas: <code>if</code>, <code>while</code>, <code>for</code>, <code>class</code>, <code>return</code>â€¦</li>
<li>SÃ­mbolos: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>=</code>, <code>==</code>, <code>{}</code>, <code>()</code>â€¦</li>
<li>Identificadores: nomes de variÃ¡veis, funÃ§Ãµes, classes etc.</li>
</ul>
</li>
<li>
<p><strong>Sintaxe (gramÃ¡tica)</strong></p>
<ul>
<li>Como essas palavras podem ser <strong>combinadas corretamente</strong></li>
<li>Exemplo:
<ul>
<li>Sintaticamente correto: <code>if (x > 10) { return x; }</code></li>
<li>Sintaticamente errado: <code>if x > 10) { return x }</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>SemÃ¢ntica (significado)</strong></p>
<ul>
<li>O que o cÃ³digo <strong>realmente faz</strong></li>
<li>Um cÃ³digo pode:
<ul>
<li>Compilar = sintaxe correta</li>
<li>Mas estar lÃ³gico/semanticamente errado</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="sintaxe--semÃ¢ntica">Sintaxe Ã— SemÃ¢ntica</h3>
<ul>
<li><strong>Sintaxe:</strong> â€œfrase bem escritaâ€</li>
<li><strong>SemÃ¢ntica:</strong> â€œfrase faz sentido?â€</li>
</ul>
<p>Exemplo:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">int</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 10</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">int</span><span style="color:#E1E4E8"> y </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">int</span><span style="color:#E1E4E8"> z </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">/</span><span style="color:#E1E4E8"> y;</span><span style="color:#6A737D"> // Sintaxe correta, semÃ¢ntica problemÃ¡tica (divisÃ£o por zero)</span></span></code></pre>
<blockquote>
<p><strong>Fraseâ€‘Ã¢ncora:</strong><br>
<em>â€œO compilador cuida da sintaxe; <strong>vocÃª</strong> cuida da semÃ¢ntica.â€</em></p>
</blockquote>
<hr>
<h2 id="4-ortogonalidade--previsibilidade-da-linguagem">4. Ortogonalidade â€“ previsibilidade da linguagem</h2>
<p><strong>Ortogonalidade</strong> = quÃ£o <strong>coerente e previsÃ­vel</strong> Ã© a combinaÃ§Ã£o dos recursos da linguagem.</p>
<ul>
<li>
<p>Linguagem <strong>mais ortogonal</strong>:</p>
<ul>
<li>Poucas exceÃ§Ãµes</li>
<li>Regras se combinam de forma previsÃ­vel</li>
<li>Mais fÃ¡cil de aprender e usar</li>
</ul>
</li>
<li>
<p>Linguagem <strong>menos ortogonal</strong>:</p>
<ul>
<li>Muitos casos especiais</li>
<li>â€œAqui funciona, ali nÃ£oâ€</li>
<li>Mais fÃ¡cil errar por detalhe</li>
</ul>
</li>
</ul>
<p>Exemplo clÃ¡ssico de reduÃ§Ã£o de ortogonalidade:</p>
<ul>
<li>Operador <code>+</code> em algumas linguagens:
<ul>
<li>Com nÃºmeros: <strong>soma</strong></li>
<li>Com strings: <strong>concatenaÃ§Ã£o</strong></li>
</ul>
</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#79B8FF">1</span><span style="color:#F97583"> +</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">// 2</span></span>
<span class="line"><span style="color:#9ECBFF">"1"</span><span style="color:#F97583"> +</span><span style="color:#9ECBFF"> "1"</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">// "11"</span></span></code></pre>
<hr>
<h2 id="5-gramÃ¡tica-formal-e-bnf-backusnaur-form">5. GramÃ¡tica formal e BNF (Backusâ€“Naur Form)</h2>
<p>Para descrever a sintaxe de uma linguagem <strong>sem ambiguidade</strong>, usamos <strong>gramÃ¡ticas formais</strong>.</p>
<h3 id="o-que-Ã©-bnf">O que Ã© BNF?</h3>
<ul>
<li>Ã‰ uma <strong>metalinguagem</strong>:
<ul>
<li>Uma linguagem usada para <strong>descrever outra linguagem</strong></li>
</ul>
</li>
<li>Define:
<ul>
<li>Quais construÃ§Ãµes sÃ£o vÃ¡lidas</li>
<li>Como montar sentenÃ§as corretas</li>
</ul>
</li>
</ul>
<p>MetÃ¡fora visual:</p>
<blockquote>
<p>Pense no BNF como o <strong>manual de montagem LEGO da linguagem</strong>.<br>
Ele nÃ£o diz o que vocÃª vai construir (programa), mas <strong>como as peÃ§as se encaixam</strong>.</p>
</blockquote>
<h3 id="componentes-bÃ¡sicos-do-bnf">Componentes bÃ¡sicos do BNF</h3>
<ul>
<li><strong>SÃ­mbolos nÃ£o terminais</strong>: sÃ£o â€œconceitosâ€ a serem detalhados
<ul>
<li>Ex.: <code>&#x3C;expressao></code>, <code>&#x3C;termo></code>, <code>&#x3C;fator></code>, <code>&#x3C;comando></code></li>
</ul>
</li>
<li><strong>SÃ­mbolos terminais</strong>: sÃ£o os tokens reais da linguagem
<ul>
<li>Ex.: <code>if</code>, <code>=</code>, <code>+</code>, <code>;</code>, identificadores</li>
</ul>
</li>
<li><strong>ProduÃ§Ãµes</strong>: regras que indicam como um nÃ£o terminal se expande</li>
</ul>
<p>Exemplo simplificado:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>&#x3C;programa> ::= "inicio" &#x3C;lista-comandos> "fim"</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&#x3C;comando> ::= &#x3C;variavel> "=" &#x3C;expressao></span></span>
<span class="line"><span></span></span>
<span class="line"><span>&#x3C;expressao> ::= &#x3C;termo> | &#x3C;termo> "+" &#x3C;expressao></span></span></code></pre>
<hr>
<h2 id="6-Ã¡rvore-sintÃ¡tica-parse-tree">6. Ãrvore sintÃ¡tica (parse tree)</h2>
<p>A <strong>Ã¡rvore sintÃ¡tica</strong> Ã© uma representaÃ§Ã£o visual de como o cÃ³digo foi interpretado pela gramÃ¡tica.</p>
<p>Exemplo de cÃ³digo:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="txt"><code><span class="line"><span>x = x + y</span></span></code></pre>
<p>Ãrvore sintÃ¡tica (visÃ£o mental):</p>
<ul>
<li>No topo: <code>&#x3C;comando-atribuicao></code></li>
<li>Filhos:
<ul>
<li><code>&#x3C;variavel></code> â†’ <code>x</code></li>
<li><code>=</code></li>
<li><code>&#x3C;expressao></code>:
<ul>
<li><code>&#x3C;variavel></code> â†’ <code>x</code></li>
<li><code>+</code></li>
<li><code>&#x3C;variavel></code> â†’ <code>y</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Uso prÃ¡tico:</strong><br>
Compiladores usam Ã¡rvores sintÃ¡ticas para <strong>verificar</strong> e <strong>traduzir</strong> o cÃ³digo para mÃ¡quina.</p>
</blockquote>
<hr>
<h2 id="7-grandes-paradigmas-de-programaÃ§Ã£o">7. Grandes paradigmas de programaÃ§Ã£o</h2>
<h3 id="71-paradigma-imperativo">7.1. Paradigma imperativo</h3>
<ul>
<li>Foco: <strong>â€œcomo fazerâ€</strong> (passo a passo)</li>
<li>VocÃª dÃ¡ <strong>comandos diretos</strong> ao computador:
<ul>
<li>AtribuiÃ§Ãµes</li>
<li>AlteraÃ§Ã£o de variÃ¡veis</li>
<li>Controle de fluxo (<code>if</code>, <code>for</code>, <code>while</code>)</li>
</ul>
</li>
</ul>
<p>CaracterÃ­sticas:</p>
<ul>
<li>Estado <strong>mutÃ¡vel</strong> (variÃ¡veis mudam de valor)</li>
<li>ExecuÃ§Ã£o <strong>sequencial</strong> (linha a linha, salvo desvios de fluxo)</li>
<li>Muito fÃ¡cil de mapear em <strong>fluxogramas</strong> e <strong>pseudocÃ³digo</strong></li>
</ul>
<p>Exemplos de linguagens com forte base imperativa:</p>
<ul>
<li>C, Pascal, BASIC, partes de Java, C#, PHP, JavaScript</li>
</ul>
<hr>
<h3 id="72-programaÃ§Ã£o-estruturada">7.2. ProgramaÃ§Ã£o estruturada</h3>
<p>EvoluÃ§Ã£o do imperativo.</p>
<ul>
<li>Ideia central: <strong>organizar</strong> melhor o cÃ³digo.</li>
<li>Ferramentas principais:
<ul>
<li><strong>FunÃ§Ãµes</strong> / procedimentos (sub-rotinas)</li>
<li>Controle de fluxo estruturado (sem <code>goto</code> espalhado)</li>
<li>Escopo de variÃ¡veis bem definido (local vs global)</li>
</ul>
</li>
</ul>
<p>Problema antigo:</p>
<ul>
<li>CÃ³digo estilo â€œespagueteâ€ com muitos <code>goto</code></li>
<li>DifÃ­cil de entender e manter</li>
</ul>
<p>SoluÃ§Ã£o:</p>
<ul>
<li><strong>ModularizaÃ§Ã£o</strong>:
<ul>
<li>Quebrar o problema em <strong>partes menores e reutilizÃ¡veis</strong></li>
<li>Criar funÃ§Ãµes coerentes: cada uma faz <strong>uma coisa bem feita</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Fraseâ€‘Ã¢ncora:</strong><br>
<em>â€œProgramaÃ§Ã£o estruturada Ã© transformar um monstro de 1000 linhas em vÃ¡rios blocos de 20 linhas que fazem sentido.â€</em></p>
</blockquote>
<hr>
<h3 id="73-programaÃ§Ã£o-orientada-a-objetos-poo">7.3. ProgramaÃ§Ã£o Orientada a Objetos (POO)</h3>
<p>Outra evoluÃ§Ã£o do imperativo.</p>
<ul>
<li>Em vez de focar em funÃ§Ãµes soltas, focamos em <strong>objetos</strong>.</li>
<li>Objeto = <strong>dados + comportamentos</strong> sobre esses dados.</li>
</ul>
<h4 id="componentes-principais">Componentes principais</h4>
<ul>
<li><strong>Classe</strong>: molde, â€œtipoâ€ do objeto</li>
<li><strong>Objeto</strong>: instÃ¢ncia concreta da classe</li>
<li><strong>Atributos</strong>: dados (estado)</li>
<li><strong>MÃ©todos</strong>: funÃ§Ãµes (comportamento)</li>
</ul>
<p>Exemplo mental:</p>
<ul>
<li>Classe <code>Pessoa</code>:
<ul>
<li>Atributos: <code>nome</code>, <code>cpf</code>, <code>dataNascimento</code></li>
<li>MÃ©todos: <code>validarCpf()</code>, <code>calcularIdade()</code></li>
</ul>
</li>
</ul>
<p>Pilares importantes:</p>
<ol>
<li>
<p><strong>Encapsulamento</strong></p>
<ul>
<li>Esconder detalhes internos</li>
<li>Expor apenas o que interessa (interface)</li>
</ul>
</li>
<li>
<p><strong>HeranÃ§a</strong></p>
<ul>
<li>Uma classe â€œfilhaâ€ reaproveita comportamento da â€œmÃ£eâ€</li>
<li>Ex.: <code>Funcionario</code> herda de <code>Pessoa</code></li>
</ul>
</li>
<li>
<p><strong>Polimorfismo</strong></p>
<ul>
<li>Objetos diferentes podem <strong>responder de maneiras diferentes</strong> Ã  mesma mensagem</li>
<li>Ex.: <code>pagarSalario()</code> faz coisas diferentes em <code>FuncionarioCLT</code> e <code>FuncionarioPJ</code></li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>Fraseâ€‘Ã¢ncora:</strong><br>
<em>â€œNa POO, o comportamento certo <strong>mora dentro do objeto certo</strong>.â€</em></p>
</blockquote>
<hr>
<h3 id="74-paradigma-funcional">7.4. Paradigma funcional</h3>
<p>Muda a forma de pensar:</p>
<ul>
<li>Menos â€œcomo fazer passo a passoâ€</li>
<li>Mais â€œ<strong>o que calcular</strong>â€</li>
</ul>
<p>Conceitos centrais:</p>
<ol>
<li>
<p><strong>FunÃ§Ãµes puras</strong></p>
<ul>
<li>Mesma entrada â†’ mesma saÃ­da</li>
<li>Sem efeitos colaterais (nÃ£o mexem em variÃ¡veis globais etc.)</li>
</ul>
</li>
<li>
<p><strong>Imutabilidade</strong></p>
<ul>
<li>Dados nÃ£o sÃ£o alterados, sÃ£o <strong>copiados com mudanÃ§as</strong></li>
<li>Em vez de â€œatualizarâ€ um objeto, cria-se um <strong>novo</strong> com estado atualizado</li>
</ul>
</li>
</ol>
<p>Vantagens:</p>
<ul>
<li>Menos bugs de â€œestado inesperadoâ€</li>
<li>FÃ¡cil de raciocinar em ambientes concorrentes/assÃ­ncronos</li>
<li>Ã“timo para processamento de dados, coleÃ§Ãµes, pipelines (<code>map</code>, <code>filter</code>, <code>reduce</code>)</li>
</ul>
<p>Exemplos:</p>
<ul>
<li>Haskell, Scheme</li>
<li>TraÃ§os funcionais em: Java (streams, lambdas), JavaScript, Python, C#, etc.</li>
</ul>
<hr>
<h3 id="75-paradigma-lÃ³gico">7.5. Paradigma lÃ³gico</h3>
<ul>
<li>Baseado em <strong>lÃ³gica formal</strong></li>
<li>Em vez de comandos, vocÃª descreve:
<ul>
<li><strong>Fatos</strong></li>
<li><strong>Regras</strong></li>
</ul>
</li>
<li>O sistema tenta <strong>inferir</strong> respostas com base nesses fatos e regras.</li>
</ul>
<p>Exemplo de pergunta (query):</p>
<blockquote>
<p>â€œDadas essas regras, Ã© verdade que X Ã© pai de Y?â€</p>
</blockquote>
<p>Linguagem clÃ¡ssica:</p>
<ul>
<li><strong>Prolog</strong></li>
</ul>
<p>Usado em:</p>
<ul>
<li>Sistemas especialistas</li>
<li>InteligÃªncia artificial clÃ¡ssica</li>
<li>Motores de inferÃªncia</li>
</ul>
<hr>
<h3 id="76-declarativo--procedural-imperativo">7.6. Declarativo Ã— Procedural (imperativo)</h3>
<ul>
<li>
<p><strong>Declarativo</strong>:</p>
<ul>
<li>VocÃª diz <strong>o que</strong> quer</li>
<li>O sistema decide <strong>como</strong> chegar lÃ¡</li>
<li>Exemplos: SQL, Prolog, partes de linguagens funcionais</li>
</ul>
</li>
<li>
<p><strong>Procedural/imperativo</strong>:</p>
<ul>
<li>VocÃª diz <strong>passo a passo</strong> como fazer</li>
<li>Ex.: C, muitos cÃ³digos em Java, PHP, etc.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Mapa mental rÃ¡pido:</strong></p>
<ul>
<li><strong>Declarativo</strong> â†’ â€œEu quero esse resultado.â€</li>
<li><strong>Imperativo</strong> â†’ â€œFaÃ§a isso, depois isso, depois aquiloâ€¦â€</li>
</ul>
</blockquote>
<hr>
<h2 id="8-operadores-precedÃªncia-e-associatividade">8. Operadores, precedÃªncia e associatividade</h2>
<h3 id="precedÃªncia">PrecedÃªncia</h3>
<p>Define <strong>quem vem primeiro</strong> em uma expressÃ£o.</p>
<p>Exemplo:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="txt"><code><span class="line"><span>5 - 3 + 2</span></span></code></pre>
<p>Sem parÃªnteses, a linguagem segue uma ordem:</p>
<ul>
<li>MultiplicaÃ§Ã£o e divisÃ£o antes de soma e subtraÃ§Ã£o</li>
<li>Em lÃ³gicas: relacionais antes de <code>&#x26;&#x26;</code>, <code>||</code>, etc.</li>
</ul>
<h3 id="associatividade">Associatividade</h3>
<p>Quando operadores tÃªm <strong>mesma precedÃªncia</strong>, a associatividade decide a direÃ§Ã£o:</p>
<ul>
<li>Da esquerda para a direita
<ul>
<li>Comum em <code>+</code>, <code>-</code></li>
</ul>
</li>
<li>Da direita para a esquerda
<ul>
<li>Comum em atribuiÃ§Ã£o em algumas linguagens</li>
</ul>
</li>
</ul>
<p>Exemplo:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="txt"><code><span class="line"><span>5 - 3 + 2  â†’  (5 - 3) + 2 = 4</span></span></code></pre>
<blockquote>
<p><strong>Boa prÃ¡tica:</strong><br>
<em>Na dÃºvida, use <strong>parÃªnteses</strong>. CÃ³digo legÃ­vel > cÃ³digo â€œespertoâ€.</em></p>
</blockquote>
<hr>
<h2 id="9-tipagem-e-conversÃµes">9. Tipagem e conversÃµes</h2>
<h3 id="tipagem-forte-vs-fraca">Tipagem forte vs fraca</h3>
<ul>
<li>
<p><strong>Fortemente tipadas</strong> (ex.: Java, C#, C em boa parte):</p>
<ul>
<li>ConversÃµes costumam ser <strong>explÃ­citas</strong></li>
<li>O compilador reclama se algo estiver estranho</li>
</ul>
</li>
<li>
<p><strong>Fracamente tipadas</strong> (ex.: JavaScript, PHP):</p>
<ul>
<li>Fazem muitas conversÃµes <strong>automÃ¡ticas</strong></li>
<li>FÃ¡ceis para comeÃ§ar, mas perigosas em sistemas grandes</li>
</ul>
</li>
</ul>
<h3 id="riscos-comuns">Riscos comuns</h3>
<ul>
<li>Perda de precisÃ£o (ex.: <code>3.14</code> â†’ <code>3</code>)</li>
<li>ConversÃ£o de string invÃ¡lida para nÃºmero</li>
<li>ComparaÃ§Ãµes ambÃ­guas (<code>"10" == 10</code> em JS, por exemplo)</li>
</ul>
<blockquote>
<p><strong>Fraseâ€‘Ã¢ncora:</strong><br>
<em>â€œO tipo certo, no lugar certo, evita bug chato e difÃ­cil de achar.â€</em></p>
</blockquote>
<hr>
<h2 id="10-linguagens-multiparadigma">10. Linguagens multiparadigma</h2>
<p>Hoje, a maioria das linguagens populares Ã© <strong>multiparadigma</strong>:</p>
<ul>
<li>Java, C#, Python, JavaScript, Kotlin, etc.</li>
<li>Suportam:
<ul>
<li>Estilo imperativo</li>
<li>Estruturado</li>
<li>Orientado a objetos</li>
<li>TraÃ§os funcionais (lambdas, streams, map/filter/reduce)</li>
</ul>
</li>
</ul>
<p>Isso Ã© poderoso, mas:</p>
<ul>
<li><strong>NÃ£o</strong> significa que vocÃª deve misturar tudo o tempo todo</li>
<li>Precisa de <strong>critÃ©rio</strong> para escolher o estilo adequado a cada problema</li>
</ul>
<hr>
<h2 id="11-como-escolher-paradigmalinguagem">11. Como escolher paradigma/linguagem?</h2>
<p>Use este mini-checklist mental:</p>
<ol>
<li>
<p><strong>Problema baseado em regras, fatos, inferÃªncia?</strong></p>
<ul>
<li>Paradigma lÃ³gico / declarativo</li>
</ul>
</li>
<li>
<p><strong>Muita transformaÃ§Ã£o de dados, pouca dependÃªncia de estado?</strong></p>
<ul>
<li>Paradigma funcional</li>
</ul>
</li>
<li>
<p><strong>DomÃ­nio rico em entidades do mundo real (pessoas, pedidos, contas, produtos)?</strong></p>
<ul>
<li>ProgramaÃ§Ã£o orientada a objetos</li>
</ul>
</li>
<li>
<p><strong>Problema exige controle fino de passo a passo e estado?</strong></p>
<ul>
<li>Paradigma imperativo / estruturado</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>Regra de ouro:</strong><br>
<em>â€œEspecialize-se em uma linguagem, mas <strong>nÃ£o feche os olhos</strong> para outras formas de pensar.â€</em></p>
</blockquote>
<hr>
<h2 id="12-erros-conceituais-comuns-para-nÃ£o-cair-neles">12. Erros conceituais comuns (para nÃ£o cair neles)</h2>
<ol>
<li>
<p><strong>â€œSe compilou, tÃ¡ certo.â€</strong></p>
<ul>
<li>NÃ£o! Compilar sÃ³ garante sintaxe vÃ¡lida.</li>
<li>Erros lÃ³gicos/semÃ¢nticos continuam lÃ¡.</li>
</ul>
</li>
<li>
<p><strong>Omitir parÃªnteses em expressÃµes complexas</strong></p>
<ul>
<li>Pode mudar o resultado sem vocÃª perceber.</li>
</ul>
</li>
<li>
<p><strong>Assumir que <code>+</code> sempre soma nÃºmeros</strong></p>
<ul>
<li>Em linguagens com concatenaÃ§Ã£o, pode produzir resultados estranhos.</li>
</ul>
</li>
<li>
<p><strong>Ignorar escopo de variÃ¡veis</strong></p>
<ul>
<li>VariÃ¡veis globais demais â†’ bugs difÃ­ceis de rastrear.</li>
</ul>
</li>
<li>
<p><strong>Misturar paradigmas sem critÃ©rio</strong></p>
<ul>
<li>CÃ³digo vira um Frankenstein difÃ­cil de manter.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="13-resumo-relÃ¢mpago-da-aula">13. Resumo relÃ¢mpago da aula</h2>
<ul>
<li>Linguagem = vocabulÃ¡rio + sintaxe + semÃ¢ntica + regras de uso</li>
<li>Paradigma = <strong>modo de pensar</strong> e organizar soluÃ§Ãµes</li>
<li>Imperativo: foco no <strong>como fazer</strong></li>
<li>Estruturado: organizaÃ§Ã£o em <strong>funÃ§Ãµes e blocos claros</strong></li>
<li>POO: foco em <strong>objetos, atributos e mÃ©todos</strong></li>
<li>Funcional: foco em <strong>funÃ§Ãµes puras e imutabilidade</strong></li>
<li>LÃ³gico: foco em <strong>regras e inferÃªncias</strong></li>
<li>Declarativo Ã— Procedural: <strong>o quÃª</strong> vs <strong>como</strong></li>
<li>BNF: gramÃ¡tica formal â†’ base de compiladores</li>
<li>Ortogonalidade: linguagem previsÃ­vel, com poucas exceÃ§Ãµes</li>
</ul>
<hr>
<h2 id="14-como-revisar-essa-aula-usando-memorizaÃ§Ã£o-ativa">14. Como revisar essa aula usando memorizaÃ§Ã£o ativa</h2>
<h3 id="passo-1--revisÃ£o-rÃ¡pida-em-510-minutos">Passo 1 â€“ RevisÃ£o rÃ¡pida (em 5â€“10 minutos)</h3>
<ul>
<li>Leia apenas:
<ul>
<li>TÃ­tulos das seÃ§Ãµes</li>
<li>Frasesâ€‘Ã¢ncora em destaque</li>
<li>Listas principais</li>
</ul>
</li>
</ul>
<h3 id="passo-2--active-recall-sem-olhar-o-material">Passo 2 â€“ Active Recall (sem olhar o material)</h3>
<p>Feche o arquivo e tente responder de cabeÃ§a:</p>
<ol>
<li>O que Ã© <strong>sintaxe</strong>? O que Ã© <strong>semÃ¢ntica</strong>?</li>
<li>DiferenÃ§a entre imperativo, POO, funcional e lÃ³gico.</li>
<li>O que Ã© <strong>funÃ§Ã£o pura</strong>? O que Ã© <strong>imutabilidade</strong>?</li>
<li>O que Ã© <strong>BNF</strong> e para que serve?</li>
<li>Exemplos de situaÃ§Ãµes onde POO Ã© melhor; outras onde funcional Ã© melhor.</li>
</ol>
<p>Depois, confira no material onde acertou e onde confundiu.</p>
<h3 id="passo-3--repetiÃ§Ã£o-espaÃ§ada">Passo 3 â€“ RepetiÃ§Ã£o espaÃ§ada</h3>
<ul>
<li>Dia 1: leia a aula completa</li>
<li>Dia 2: faÃ§a apenas o <strong>resumo relÃ¢mpago</strong></li>
<li>Dia 4: refaÃ§a o <strong>Active Recall</strong></li>
<li>Dia 7: explique o conteÃºdo para alguÃ©m (ou em voz alta para vocÃª mesmo)</li>
</ul>
<blockquote>
<p><strong>Dica final:</strong><br>
<em>â€œVocÃª realmente aprende quando consegue <strong>explicar com suas prÃ³prias palavras</strong>.â€</em></p>
</blockquote>
<hr>
<p><strong>Fim da Aula 01 â€“ Paradigmas de Linguagens de ProgramaÃ§Ã£o (VisÃ£o Geral)</strong><br>
Use esta aula como <strong>mapa geral</strong>; as prÃ³ximas mergulham fundo em cada paradigma.</p> </main> <footer class="site-footer"> <div class="container"> <p>Projeto de estudo â€œParadigmas de ProgramaÃ§Ã£oâ€</p> </div> </footer> </body></html>